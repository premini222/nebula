<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hand Tracking 3D Galaxy</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', sans-serif; }
        
        /* UI Container */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 15px 0; font-size: 16px; letter-spacing: 1px; text-transform: uppercase; color: #aaa; }
        
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-size: 12px; font-weight: bold; }

        /* Buttons */
        .btn-group { display: flex; gap: 5px; flex-wrap: wrap; }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            flex: 1;
        }
        button:hover, button.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        /* Color Picker */
        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* Webcam feedback (small) */
        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transform: scaleX(-1); /* Mirror effect */
            z-index: 5;
            object-fit: cover;
        }
        
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }

        .gesture-status {
            margin-top: 10px;
            font-size: 11px;
            color: #4a90e2;
            height: 15px;
        }
    </style>
</head>
<body>

<div id="loading">Loading AI Models...</div>

<div id="ui-container">
    <h2>Galaxy Controller</h2>
    
    <div class="control-group">
        <label>SCENE TYPE</label>
        <div class="btn-group">
            <button class="active" onclick="changeScene('nebula')">Nebula</button>
            <button onclick="changeScene('saturn')">Saturn</button>
            <button onclick="changeScene('cube')">Box</button>
        </div>
    </div>

    <div class="control-group">
        <label>COLOR MODE</label>
        <div class="btn-group" style="margin-bottom: 8px;">
            <button id="btn-single" class="active" onclick="toggleRainbow(false)">Single</button>
            <button id="btn-rainbow" onclick="toggleRainbow(true)">Rainbow</button>
        </div>
        <input type="color" id="colorPicker" value="#00ffff">
    </div>

    <div class="control-group">
        <label>GESTURE STATUS</label>
        <div class="gesture-status" id="gesture-feedback">Waiting for hands...</div>
    </div>
</div>

<video id="webcam-preview" playsinline></video>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
            "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- Variables ---
    let scene, camera, renderer, particles, geometry, material;
    let isRainbow = false;
    let sceneType = 'nebula';
    let targetRotationX = 0;
    let targetRotationY = 0;
    let targetScale = 1.0;
    
    const PARTICLE_COUNT = 5000;
    const canvasColor = 0x000000;
    
    // UI Elements
    const gestureFeedback = document.getElementById('gesture-feedback');
    const videoElement = document.getElementById('webcam-preview');
    const loadingElement = document.getElementById('loading');
    const colorPicker = document.getElementById('colorPicker');

    // --- Three.js Setup ---
    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        createParticles('nebula');
        animate();
    }

    // --- Particle System Logic ---
    function createParticles(type) {
        if (particles) scene.remove(particles);

        geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const color = new THREE.Color();
        const baseColor = new THREE.Color(colorPicker.value);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;

            if (type === 'nebula') {
                x = (Math.random() - 0.5) * 100;
                y = (Math.random() - 0.5) * 100;
                z = (Math.random() - 0.5) * 100;
            } else if (type === 'saturn') {
                // Ring
                const angle = Math.random() * Math.PI * 2;
                const radius = 20 + Math.random() * 30;
                x = Math.cos(angle) * radius;
                z = Math.sin(angle) * radius;
                y = (Math.random() - 0.5) * 2; // Flat
                // Add center sphere occasionally
                if (i < PARTICLE_COUNT * 0.2) {
                    const r = Math.random() * 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
            } else if (type === 'cube') {
                x = (Math.random() - 0.5) * 40;
                y = (Math.random() - 0.5) * 40;
                z = (Math.random() - 0.5) * 40;
            }

            positions.push(x, y, z);
            sizes.push(Math.random() * 0.5); // Random sizes

            // Initialize Colors
            if (isRainbow) {
                color.setHSL(Math.random(), 1.0, 0.5);
            } else {
                color.copy(baseColor);
            }
            colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // Custom Texture for "Star" look
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

        material = new THREE.PointsMaterial({ 
            size: 1.0, 
            map: sprite,
            vertexColors: true,
            blending: THREE.AdditiveBlending, 
            depthTest: false, 
            transparent: true,
            opacity: 0.8
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
        
        // Reset transform
        particles.scale.set(1,1,1);
        particles.rotation.set(0,0,0);
        targetScale = 1.0;
        targetRotationY = 0;
    }

    // --- Interaction Logic ---
    window.changeScene = (type) => {
        sceneType = type;
        createParticles(type);
        // Update Buttons
        document.querySelectorAll('.btn-group button').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
    };

    window.toggleRainbow = (rainbow) => {
        isRainbow = rainbow;
        document.getElementById('btn-single').classList.toggle('active', !rainbow);
        document.getElementById('btn-rainbow').classList.toggle('active', rainbow);
        createParticles(sceneType);
    };

    colorPicker.addEventListener('input', (e) => {
        if (!isRainbow && particles) {
            const c = new THREE.Color(e.target.value);
            const colors = particles.geometry.attributes.color;
            for (let i = 0; i < colors.count; i++) {
                colors.setXYZ(i, c.r, c.g, c.b);
            }
            colors.needsUpdate = true;
        }
    });

    // --- MediaPipe Hands Setup ---
    // Note: We use the global `window.Hands` because we load scripts differently for quick prototyping, 
    // but here we will assume CDN script tag loads global Hands.
    async function initMediaPipe() {
        const script1 = document.createElement('script');
        script1.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
        script1.onload = () => {
            const script2 = document.createElement('script');
            script2.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";
            script2.onload = startHands;
            document.body.appendChild(script2);
        };
        document.body.appendChild(script1);
    }

    function startHands() {
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraUtils.start();
        loadingElement.style.display = 'none';
    }

    // --- Gesture Recognition & Update ---
    let prevIndexX = null;

    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            gestureFeedback.innerText = "No hand detected";
            prevIndexX = null;
            return;
        }

        const landmarks = results.multiHandLandmarks[0];

        // Key Points
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const wrist = landmarks[0];

        // 1. Calculate Distances
        // Thumb to Index (Pinch)
        const distThumbIndex = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        // Thumb to Middle 
        const distThumbMiddle = Math.hypot(thumbTip.x - middleTip.x, thumbTip.y - middleTip.y);

        // 2. Logic
        let status = "Tracking...";

        // Thresholds (Normalized coordinates 0.0 - 1.0)
        const PINCH_THRESHOLD = 0.08; 
        
        // --- Scale Up (Thumb + Index Separated drastically?) ---
        // Actually, "Separating" is hard to detect as an "event" without state. 
        // We will map distance directly to scale or increment based on state.
        // Prompt: "Thumb & Index separate -> Scale Up".
        // Let's implement: If Thumb & Index are FAR apart (> 0.2), Scale grows.
        
        if (distThumbIndex > 0.2) {
            targetScale += 0.02;
            status = "Scaling UP (Open)";
        }

        // --- Scale Out/Down (Thumb + Middle Close) ---
        if (distThumbMiddle < PINCH_THRESHOLD) {
            targetScale -= 0.02;
            status = "Scaling DOWN (Pinch Middle)";
        }
        
        // Clamp Scale
        targetScale = Math.max(0.2, Math.min(targetScale, 5.0));

        // --- Swipe / Rotate (Index & Middle UP and moving) ---
        // Check if Index and Middle are extended (Y is significantly higher than wrist, note Y is inverted in some coords but usually 0 is top)
        // Simple check: Index and Middle are somewhat close to each other, acting as a pointer
        const distIndexMiddle = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
        
        if (distIndexMiddle < 0.1 && distThumbIndex > 0.1) {
            // Two fingers together, thumb away (Swipe pose)
            status = "Swiping / Rotating";
            
            if (prevIndexX !== null) {
                const deltaX = indexTip.x - prevIndexX;
                // Move camera or rotate object. Let's rotate object.
                // MediaPipe X is mirrored usually.
                targetRotationY += deltaX * 5; 
            }
            prevIndexX = indexTip.x;
        } else {
            prevIndexX = null;
        }

        gestureFeedback.innerText = status;
    }

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);

        if (particles) {
            // Smooth interpolation for Scale
            particles.scale.x += (targetScale - particles.scale.x) * 0.1;
            particles.scale.y += (targetScale - particles.scale.y) * 0.1;
            particles.scale.z += (targetScale - particles.scale.z) * 0.1;

            // Smooth interpolation for Rotation
            particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.05;
            // Add subtle auto rotation
            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            // Twinkle Effect (update colors slightly if single color, or cycle rainbow)
            const colors = particles.geometry.attributes.color;
            if (isRainbow) {
                const time = Date.now() * 0.001;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // Simple hue cycle
                    const h = (i / PARTICLE_COUNT + time * 0.2) % 1.0;
                    const c = new THREE.Color().setHSL(h, 1.0, 0.5);
                    colors.setXYZ(i, c.r, c.g, c.b);
                }
                colors.needsUpdate = true;
            } else {
                // Twinkle alpha/brightness simulation by scaling vertices? 
                // BufferGeometry size update is expensive. 
                // Let's just rotate slightly for sparkle.
            }
        }

        renderer.render(scene, camera);
    }

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    initThree();
    initMediaPipe();

</script>
</body>
</html>