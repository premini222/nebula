<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Twinkling Nebula - Shader Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Helvetica Neue', Arial, sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
        #ui-container { position: absolute; top: 15px; left: 15px; z-index: 100; background: rgba(10, 10, 20, 0.85); backdrop-filter: blur(15px); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.15); color: white; width: 240px; transition: all 0.3s ease; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #ui-container.minimized { width: 150px; height: 40px; }
        .ui-header { padding: 12px 15px; background: rgba(255, 255, 255, 0.05); display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
        .ui-header h2 { margin: 0; font-size: 11px; letter-spacing: 2px; color: #4a90e2; text-transform: uppercase; }
        .min-btn { font-size: 18px; line-height: 0; color: #888; }
        .ui-content { padding: 15px; }
        #ui-container.minimized .ui-content { display: none; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 9px; font-weight: bold; color: #888; text-transform: uppercase; }
        .btn-group { display: flex; gap: 5px; margin-bottom: 8px; }
        button { background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.2); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 10px; flex: 1; }
        button.active { background: #4a90e2; border-color: #4a90e2; font-weight: bold; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #4a90e2; }
        input[type="color"] { width: 100%; height: 25px; border: none; background: none; cursor: pointer; }
        .guide { margin-top: 10px; font-size: 9px; color: #555; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px; line-height: 1.4; }
    </style>
</head>
<body>

<div id="ui-container">
    <div class="ui-header" onclick="toggleUI()">
        <h2>Nebula Vision</h2>
        <div class="min-btn" id="min-btn">−</div>
    </div>
    <div class="ui-content">
        <div class="control-group">
            <label>Color Mode</label>
            <div class="btn-group">
                <button id="btn-single" class="active" onclick="toggleRainbow(false)">Solid</button>
                <button id="btn-rainbow" onclick="toggleRainbow(true)">Rainbow</button>
            </div>
            <input type="color" id="colorPicker" value="#00d4ff">
        </div>
        <div class="control-group" id="sat-control" style="display:none;">
            <label>Rainbow Saturation</label>
            <input type="range" id="saturationSlider" min="0" max="1" step="0.01" value="0.7">
        </div>
        <div class="guide">
            Swipe: Rotate | Pinch: Zoom<br>
            Double Tap: Reset Rotation<br>
            (30,000 Indiv. Twinkling Stars)
        </div>
    </div>
</div>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, particles, starfield;
    let isRainbow = false;
    let rainbowSaturation = 0.7;
    let targetRotationY = 0, targetRotationX = 0;
    let targetScale = 1.0;
    let isPointerDown = false;
    let lastPointerX = 0, lastPointerY = 0;
    let lastPinchDist = 0;

    const PARTICLE_COUNT = 30000;

    // --- Shader Source ---
    const vertexShader = `
        attribute float twinkleSpeed;
        attribute float twinkleOffset;
        varying vec3 vColor;
        varying float vTwinkle;
        uniform float uTime;
        uniform float uSize;

        void main() {
            vColor = color;
            // 個別に明滅を計算 (0.3〜1.0の間で揺らす)
            vTwinkle = 0.65 + 0.35 * sin(uTime * twinkleSpeed + twinkleOffset);
            
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = uSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    `;

    const fragmentShader = `
        uniform sampler2D uTexture;
        varying vec3 vColor;
        varying float vTwinkle;

        void main() {
            vec4 tex = texture2D(uTexture, gl_PointCoord);
            if (tex.a < 0.1) discard;
            // 明滅度を適用
            gl_FragColor = vec4(vColor * vTwinkle, tex.a);
        }
    `;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
        camera.position.z = 250;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        createStarfield();
        createNebula();
        setupEvents();
        animate();
    }

    function createStarfield() {
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) {
            starPos.push((Math.random()-0.5)*3500, (Math.random()-0.5)*3500, (Math.random()-0.5)*3500);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        starfield = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0x444444, size: 1 }));
        scene.add(starfield);
    }

    function createNebula() {
        if (particles) {
            scene.remove(particles);
            particles.geometry.dispose();
            particles.material.dispose();
        }

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const twinkleSpeeds = [];
        const twinkleOffsets = [];
        const baseColor = new THREE.Color(document.getElementById('colorPicker').value);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = 150 * Math.cbrt(Math.random());
            
            positions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );

            const c = isRainbow 
                ? new THREE.Color().setHSL((i/PARTICLE_COUNT), rainbowSaturation, 0.5) 
                : baseColor.clone().multiplyScalar(0.6 + Math.random()*0.4);
            colors.push(c.r, c.g, c.b);

            // 個別のパラメータ
            twinkleSpeeds.push(2.0 + Math.random() * 4.0); // 明滅の速さ
            twinkleOffsets.push(Math.random() * Math.PI * 2); // 開始タイミング
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('twinkleSpeed', new THREE.Float32BufferAttribute(twinkleSpeeds, 1));
        geometry.setAttribute('twinkleOffset', new THREE.Float32BufferAttribute(twinkleOffsets, 1));

        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uTexture: { value: sprite },
                uSize: { value: 2.5 }
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
    }

    function setupEvents() {
        const el = renderer.domElement;
        el.addEventListener('pointerdown', (e) => {
            if (e.target.closest('#ui-container')) return;
            isPointerDown = true;
            lastPointerX = e.clientX; lastPointerY = e.clientY;
        });

        window.addEventListener('pointermove', (e) => {
            if (!isPointerDown) return;
            const dx = e.clientX - lastPointerX;
            const dy = e.clientY - lastPointerY;
            targetRotationY -= dx * 0.005;
            targetRotationX += dy * 0.005; 
            lastPointerX = e.clientX; lastPointerY = e.clientY;
        });

        window.addEventListener('pointerup', () => { isPointerDown = false; lastPinchDist = 0; });
        el.addEventListener('dblclick', () => { targetRotationX = 0; targetRotationY = 0; });

        el.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                if (lastPinchDist > 0) targetScale = Math.max(0.1, Math.min(5, targetScale + (dist - lastPinchDist) * 0.01));
                lastPinchDist = dist;
            }
        }, { passive: false });

        window.addEventListener('wheel', (e) => {
            targetScale = Math.max(0.1, Math.min(5, targetScale - e.deltaY * 0.001));
        }, { passive: false });
    }

    window.toggleUI = () => {
        const ui = document.getElementById('ui-container');
        ui.classList.toggle('minimized');
        document.getElementById('min-btn').innerText = ui.classList.contains('minimized') ? "+" : "−";
    };

    window.toggleRainbow = (rainbow) => {
        isRainbow = rainbow;
        document.getElementById('btn-single').classList.toggle('active', !rainbow);
        document.getElementById('btn-rainbow').classList.toggle('active', rainbow);
        document.getElementById('sat-control').style.display = rainbow ? 'block' : 'none';
        createNebula();
    };

    document.getElementById('colorPicker').addEventListener('input', () => { if (!isRainbow) createNebula(); });
    document.getElementById('saturationSlider').addEventListener('input', (e) => { rainbowSaturation = parseFloat(e.target.value); createNebula(); });

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now() * 0.001;

        if (particles) {
            particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.05 + 0.001;
            particles.rotation.x += (targetRotationX - particles.rotation.x) * 0.05;
            const s = THREE.MathUtils.lerp(particles.scale.x, targetScale, 0.1);
            particles.scale.set(s, s, s);
            
            // シェーダーに時間を送ることで個別に明滅させる
            particles.material.uniforms.uTime.value = time;
        }
        if (starfield) starfield.rotation.y += 0.0001;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
